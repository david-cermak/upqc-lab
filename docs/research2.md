# Example

## Page 1
### Post-Quantum Cryptography in Embedded ### Systems and IoT The  rise  of  quantum  computing  threatens  all  current  public-key  schemes  (RSA,  ECC,  etc.).  Shor’s algorithm  can  break  these  by  efficiently  solving  factorization  or  discrete-logarithm  problems,  so “harvest-now,  decrypt-later” attacks  could  expose  long-lived  IoT  data  once  quantum  hardware matures . Embedded devices (sensors, controllers, smart cards) often use weaker crypto already and  remain  in  service  for  many  years,  so  upgrading  to  quantum-resistant algorithms  is  essential. However, post-quantum (PQ) schemes typically have  higher cost: larger key or signature sizes and more computation . Constrained platforms (e.g. ARM Cortex‑M, RISC‑V micros) must balance security against limited RAM/Flash, CPU speed, and energy. For example, a reference PQ library implementation of CRYSTALS‑Kyber-512 on a 24 MHz Cortex‑M4 required ≈0.65 M CPU cycles for keygen and ≈0.96 M for decapsulation, using ~9 KB RAM . Highly optimized assembly (“M4”) cuts this roughly in half and reduces RAM to ~2.5 KB . In contrast, a hash-based signature like SPHINCS+ can take  tens of seconds to minutes to generate a signature on the same MCU , making it impractical for many IoT uses. Thus, embedded PQC requires careful algorithm choice and implementation. ### PQC Algorithm Families and Standards Several mathematical families are in NIST’s post-quantum standardization effort, each with different trade-offs for embedded use: Lattice-based schemes (Module‑LWE, etc.) – These include CRYSTALS‑Kyber (KEM), CRYSTALS‑Dilithium (signature) and FALCON (signature), which NIST selected for standardization . They have relatively small keys and reasonable speed. For example, Kyber-512 uses an 800 B public key and 768 B ciphertext , and is quite efficient (optimized Kyber512 decapsulation on Cortex‑M4 ≈0.52 M cycles ). Dilithium-2 (a ~128-bit signature) uses ~1.3 KB public key and ~2.4 KB signature, with signing cost ~6.2 M cycles and verification ~1.46 M cycles on M4 . These lattice schemes generally scale in cost with security level; larger variants (Kyber-1024, Dilithium-4) use more cycles and memory. Hash-based signatures – SPHINCS+ (hash-based, stateless) is NIST‑approved. It offers simple security (no fancy math assumptions), but at the cost of very large signatures (tens of KB) and very slow signing/verification. On microcontrollers, SPHINCS+ signing can take from ~22 seconds up to 88 minutes at 24 MHz , which is unsuitable for most IoT. Stateful hash schemes (XMSS, LMS) have smaller signatures but require careful state management (and are already used in TPMs and some bootloaders). Some systems (Europe, Japan) even allow using LMS/XMSS directly without hybridizing with classical crypto , since they are well understood and suitable for firmware signing. Code-based KEMs – Classic McEliece (based on binary Goppa codes) was a finalist for KEM standardization. It has extremely large public keys (on the order of hundreds of kilobytes to over a megabyte ) but very fast encryption. These key sizes make it impractical for small embedded devices: e.g. McEliece public keys can be 255 KiB–1326 KiB , far exceeding typical MCU memory. Other code-based KEMs (BIKE, HQC) also had large internal data needs and relied on big integer libraries, so are hard to fit into a 64–256 KB MCU stack . Multivariate signatures – Rainbow (multivariate over GF(256)) was initially chosen by NIST, but a catastrophic key-recovery attack appeared in 2022. Even aside from that, Rainbow’s public keys 1 2 2 3 3 4 • 5 3 3 6 • 4 7 • 8 8 9 • 1

## Page 2
are huge (e.g. ~145 KiB, 694 KiB, and 1665 KiB for its parameter sets , or 57 KiB, 202 KiB, and 480 KiB in “compressed” form ) and signatures are large, so it’s ill-suited for MCUs. All variants needed more memory than a Cortex‑M4 provides . Isogeny-based (e.g. SIKE) – These had very small key sizes but very slow math; moreover, SIKE was broken in 2022. They are no longer in consideration. Overall, for constrained devices the  lattice-based and (to a lesser extent) hash-based approaches have been most promising: NIST’s first standards are all lattice or hash-based , reflecting good performance in software. In contrast, code- and multivariate-based schemes tend to have huge keys or heavy dependencies (big-number libraries), making them “arguably unsuited for a microcontroller environment” . (For example, PQM4 benchmarking notes that many such schemes simply cannot run in 196 KiB RAM .) <table>

<thead>

<tr><th>Algorithm

(Family)</th><th>Type</th><th>Key/Signature

Sizes</ th><th>Performance/Notes</th></tr> </thead><tbody> <tr> <td><b>CRYSTALS-Kyber-512</b> (Lattice ### KEM)</td> <td>KEM</td> <td>Pub Key ~800 B; Ciphertext ~768 B </td> <td>Fast (~0.5M cycles decaps on  Cortex‑M4 );  low  RAM  (~2–3 KB  optimized).  Suitable  for  TLS  key  exchange.</td>  </tr>  <tr> <td><b>CRYSTALS-Dilithium-2</b>  (Lattice  Signature)</td>  <td>Signature</td>  <td>Pub Key  ~1300 B; Signature ~2420 B</td> <td>Moderate speed: keygen ~1.4M cycles, sign ~6.15M cycles, verify ~1.46M cycles on M4 ; RAM ~12–14 KB. Widely recommended for firmware signing in constrained devices.</ td>  </tr>  <tr>  <td><b>Falcon-1024</b>  (Lattice  Signature)</td>  <td>Signature</td>  <td>Pub Key ~1.3 KB; Signature ~690 B</td> <td>Small signatures, but very heavy FFT math. Falcon-1024 signing is slower  than  Dilithium  and  uses  more  code  complexity.  (Often  used  where  small  signatures  are paramount.)</td>  </tr>  <tr>  <td><b>SPHINCS+-128f</b>  (Hash  Signature)</td>  <td>Signature</td> <td>Pub Key ~32 B; Signature ~8–10 KB</td> <td>Very large signatures; extremely slow signing (seconds to minutes) . Hardware-friendly (only hashes), but impractical for routine sensor authentication.</td> </tr> <tr> <td><b>Classic McEliece (3488)</b> (Code KEM)</td> <td>KEM</td> <td>Pub Key ~1,300 KiB; Ciphertext ~128 B</td> <td>Huge key (~1 MB) makes it impractical for low-end devices, despite very fast  encapsulation.</td>  </tr>  <tr>  <td><b>Rainbow-Ia  (multivar)</b></td>  <td>Signature</td> <td>Pub Key ~145.5 KiB (Ia) ; Signature ~66 B</td> <td>Very large keys (even compressed ~57 KiB) . The smallest variant still uses ~90 KiB private key plus state, exceeding typical MCU RAM . (Note: Rainbow was broken in 2022.)</td> </tr> <tr> <td><b>X.509 & TLS (Hybrid)</b></td> <td>Hybrid</td> <td>N/A</td> <td>In practice, many recommend hybrid signatures (PQ + traditional like ECDSA) to ensure crypto agility during migration. Government guidance (CNSA 2.0) even mandates hybrid use in some cases .</td> </tr> </tbody> </table> ### Software Libraries and Tools A number of open-source and commercial libraries now support PQC, easing integration on embedded platforms: PQClean (C library) – A collection of clean reference implementations of NIST-postulated PQ schemes with a unified API . It includes C versions of all finalists and many round-2 submissions. PQClean code is often copied or used directly in embedded projects for portability. However, its baseline C code can be memory-heavy; many projects use PQClean as a starting point and then optimize critical parts in assembly. liboqs (Open Quantum Safe) – A C library that wraps together PQClean and other PQ schemes, providing a higher-level API . It includes all popular KEMs and signatures (Kyber, Dilithium, etc.) with PLUG-IN modules. liboqs offers language bindings (C++, Python, Rust, etc.) and is used by OQS‑OpenSSL, OQS‑OpenSSH, OQS‑OpenVPN, and others . This makes it easy to 10 11 12 • 5 13 14 8 14 8 3 3 6 4 8 10 11 12 15 • 16 • 17 17 2

## Page 3
experiment with PQC in network protocols. One can use liboqs in a bare-metal IoT context, though it may need adaptation (as memory allocators in embedded RTOSes can be tricky ). wolfSSL/wolfCrypt – A commercial embedded TLS/crypto library that now includes PQ algorithms. It implements ML‑KEM (Kyber 512/768/1024), ML‑DSA (Dilithium 4x, 6x, 8x), SPHINCS+ (via liboqs), plus LMS/HSS and XMSS (stateful hash signatures) . wolfCrypt is optimized for x86 and ARM (thumb2) and designed for small footprints . It integrates into (D)TLS 1.3, MQTT, SSH, and provides hybrid ECC/PQ ciphersuites. In practice, wolfSSL’s PQ support allows embedded devices (even small MCUs) to use Kyber/Dilithium in TLS handshakes . Their wolfBoot secure bootloader uses LMS/XMSS for firmware auth , and hardware crypto offload is supported on many MCUs . mbedTLS/PSA Crypto – The popular ARM mbed TLS library is aware of PQC needs, but as of 2025 it has no built-in PQ algorithms. The team is restructuring to use the PSA Crypto API, which would allow swapping in new algorithms. However, the current PSA API assumes small, stateless keys and signatures, so it isn’t yet ready for PQC . Plans for PQ support are in the works, but embedded developers should note that adding NIST PQ curves to mbedTLS will require significant TLS-layer changes . Some research prototypes integrate liboqs with mbedTLS to add Kyber/SPHINCS to TLS on devices , but this is still experimental. Other tools/libraries: There are specialized projects like pqm4 (a benchmarking framework for ARM-M4, using PQClean code) , and PQShield’s PQCryptoLib (commercial library for ### embedded ARM with LMS, XMSS, Dilithium, Kyber). Microcontroller manufacturers are also providing libraries: ST’s new X-CUBE-PQC package for STM32 includes implementations of Kyber, Dilithium, LMS/XMSS (optimized for their crypto accelerators) . Each library/tool has trade-offs. For minimal stack usage, clean C code (PQClean) may need stack allocation adjustments or conversion to heap as shown by Silva et al. (ESP32 example) . Optimized/ assembly versions can greatly shrink RAM usage (Kyber’s M4-optimized code uses ~2–3 KB vs ~9 KB for clean code ). Developers should choose the implementation (clean, reference, or optimized) that fits memory constraints. Table 2 summarizes some notable libraries: <table>  <thead>  <tr><th>Library/Tool</th><th>PQC  Support</th><th>Platform  Notes</th></tr>  </ thead><tbody>  <tr>  <td>PQClean</td>  <td>Clean  C  reference  impls  of  NIST  PQC  schemes  (Kyber, Dilithium, Falcon, etc.) with unified API .</td> <td>Highly portable; often the basis for embedded ports.  May  need  manual  optimization  for  tight  memory.</td>  </tr>  <tr>  <td>liboqs</td> <td>Framework including PQClean and additional schemes; offers C API and language bindings .</ td>  <td>Good  for  prototyping  and  higher-level  apps.  Used  by  OQS-OpenSSL,  etc.  Embedding  in constrained  firmware  may  require  memory  tuning.</td>  </tr>  <tr>  <td>wolfCrypt  (wolfSSL)</td> <td>Built-in PQ algorithms (Kyber, Dilithium, SPHINCS+, LMS/XMSS) optimized for ARM/x86 .</td> <td>Commercial library; integrated TLS/SSH stack. Suitable for embedded use (small footprint). Includes secure boot (wolfBoot) with hash-based PQ signatures .</td> </tr> <tr> <td>mbedTLS (PSA)</td> <td>No native PQ yet; future PSA Crypto API v2 aims to add PQ schemes.</td> <td>Widely used in IoT. Currently developers must extend it manually (e.g. via liboqs) for PQ. TLS 1.3 support is being updated to  facilitate  this .</td>  </tr>  <tr>  <td>Hardware  &  SDKs</td>  <td>Microcontroller  vendors  are adding PQ crypto engines (e.g. ST’s SHA-3 accelerator for SHAKE in X-CUBE-PQC) .</td> <td>Dev tools (IDE support, examples) are emerging for PQ. Eg. Microchip’s MPLAB now supports their new PQ- ready MEC175xB controllers .</td> </tr> </tbody> </table> 18 • 19 20 21 22 23 24 • 25 25 26 • 27 28 29 3 16 17 21 23 25 28 30 3

## Page 4
### Integration and Best Practices To migrate an existing embedded system or IoT application to PQC, one should follow crypto-agility principles. Common strategies include: Hybrid schemes: Use PQ algorithms in parallel with classical ones during the transition. For example, a device might perform both ECDH and Kyber KEM in a TLS handshake (or sign a firmware image with both ECDSA and Dilithium). This doubles latency but avoids “single-point” trust in unproven PQC. Many guidelines (e.g. CNSS/CNSA 2.0) mandate or recommend PQ/T hybrid for critical systems . Modular crypto framework: Abstract the public-key layer so algorithms can be swapped. The PSA crypto API (future) and libraries like wolfSSL allow specifying a curve or KEM by name. Embedding PQ code in firmware often means adding new handshakes or signature checks, but calling through a common interface. Memory planning: As shown above, PQC requires more RAM for keys and stack. Ensure the firmware’s linker and RTOS can accommodate larger stacks or use heap. The ESP32 example in [13] illustrates allocating a larger FreeRTOS task stack to run PQClean routines . ### Secure Boot/Firmware: Replace firmware signature (often RSA/ECDSA) with PQ signatures. For instance, using Dilithium or LMS to sign boot images. WolfBoot and bootloader frameworks can often be configured with new signature schemes . Follow NIST guidance (CNSA 2.0) which says firmware signing should be among the first PQC use cases . Hardware acceleration: If possible, leverage crypto accelerators. Some MCU vendors (Microchip, ST) offer hardware units (e.g. SHAKE hash cores, modular arithmetic blocks) specifically to speed up PQ algorithms . This can drastically reduce execution time and power use. For example, ST’s SHA-3 accelerator helps speed up XMSS/LMS in secure controllers . Even without dedicated PQ units, using fast ARM instructions (SIMD, DSP) can help. Overall, integration is an ongoing process of trade-offs. One must balance performance (throughput, latency) against security, and plan for hybrid/rollback paths until PQC is fully trusted. ### Security Considerations and Transition Strategy No PQ algorithm is known to be vulnerable to quantum attacks yet, but they all rely on hard problems that could be studied intensively in the coming years. Cryptographers stress  crypto-agility: systems should be able to swap algorithms if new weaknesses appear. For instance, Bloom  et al. argue that NIST’s choice of two lattice signatures (Dilithium, Falcon) plus a hash backup (SPHINCS+) provides alternatives if one breaks . Similarly, many standards bodies recommend multi-algorithm certificates (e.g. “dual” signatures) to hedge bets. Embedded systems should also protect key material carefully: larger PQ private keys often reside in non-volatile storage or secure elements, and may need protection against side-channels (masking for large-NTT  operations,  etc.).  Notably,  an  implementation  bug  in  Kyber  (timing  leak)  was  recently discovered and patched . Always use constant-time, well-reviewed implementations. During transition, systems often use  hybrid TLS or SSH: e.g. D. J. Bernstein’s PQ experiment and wolfSSL both illustrate double-handshake or combined key exchange. Hybrid adds roughly the sum of classical+PQ compute and message sizes, but ensures that even if PQC is later broken, classical ECC still protects the session (or vice versa). Overhead is a downside, but early adopters (e.g. Google’s CECPQ2 TLS experiment) have successfully tested this on PCs and embedded Linux. • 15 • • 18 • 23 31 • 28 32 28 5 33 4

## Page 5
Government guidance reflects this: e.g. NSA’s CNSA 2.0 (2024) explicitly urges agencies to start PQC adoption now, first for digital signatures and code signing (secure boot) and second for key exchange, using hybrids where required . Similarly, ETSI and GSMA are working on PQC guidelines for networks and IoT. In practice, many IoT platforms will initially use PQC in backend servers (TLS termination) and sign firmware with PQ keys, before fully rolling PQ into the device’s own handshake logic. ### Industry Adoption and Outlook Industry  is  already  moving.  In  hardware,  Microchip’s  recent  announcement  (May  2025)  of  the MEC175xB MCU family highlights embedded PQ support: it includes immutable hardware engines for ML‑DSA (Dilithium), LMS (hash sig), and ML‑KEM (Kyber) , along with a configurable secure boot that can use CNSA 2.0 algorithms. Similarly, STMicroelectronics rolled out X-CUBE-PQC software libraries and hardware IP for its STM32 and secure MCUs, supporting Kyber, Dilithium, XMSS/LMS (accelerated by SHA‑3 unit) . These offerings show that PQC is being built into next-generation chips. On the software side, telecom and IoT consortia (GSMA, 3GPP) have published studies and guidelines for  PQC  in  IoT  networks ,  and  projects  like  QUBIP  are  demonstrating  PQ-secure  protocols  for constrained devices. Cloud and edge IoT platforms (AWS IoT, Azure IoT) are beginning to offer PQ- enabled device authentication (usually as hybrids). Major cryptography libraries (OpenSSL, GnuTLS) are integrating liboqs; wolfSSL has full support as noted above; even Windows/Linux platforms are adding PQ support to their TLS stacks. Finally,  standardization  will  continue:  NIST’s  FIPS  203/204/205  are  imminent  (Kyber,  Dilithium, SPHINCS+), ETSI is developing quantum-safe standards, and IETF has TLS drafts for PQ groups. Over the next 2–5 years we expect further hardware (e.g. TPMs, Secure Elements) to add PQ algorithms, and broad migration of IoT PKI to quantum-safe signatures. For embedded engineers, the immediate task is to evaluate critical links and firmware signatures for PQ readiness, begin testing PQC libraries on target hardware  (possibly  in  hybrid  mode),  and  follow  evolving  standards  such  as  NIST’s  and  industry consortiums’ recommendations. Sources: Authoritative  technical  papers  and  industry  reports  on  PQC  (NIST  reports,  academic benchmarks , vendor press releases , and PQC library documentation ) were used to compile this overview. Each citation links to supporting details on performance, standards, and implementations. ### Evaluating Post-Quantum Cryptographic Algorithms on Resource-Constrained Devices https://arxiv.org/html/2507.08312v1 ### pqm4: Testing and Benchmarking NIST PQC on ARM Cortex-M4 https://csrc.nist.gov/CSRC/media/Events/Second-PQC-Standardization-Conference/documents/accepted-papers/ kannwischer-pqm4.pdf pq-crystals.org https://pq-crystals.org/kyber/data/kyber-specification-round3-20210131.pdf ### NIST Releases First 3 Finalized Post-Quantum Encryption Standards | NIST https://www.nist.gov/news-events/news/2024/08/nist-releases-first-3-finalized-post-quantum-encryption-standards Post-quantum cryptography and secure boot | PQShield https://pqshield.com/secure-boot-considerations-with-pqc/ 31 32 28 34 2 3 6 4 32 28 16 21 25 1 26 2 4 6 8 9 10 11 12 14 27 3 5 7 15 31 5

## Page 6
### Evaluating Post-Quantum Cryptography on Embedded Systems: A Performance Analysis https://arxiv.org/html/2409.05298v1 research.cyber.ee https://research.cyber.ee/~janwil/publ/pqauth.pdf wolfCrypt Post Quantum | Products - wolfSSL https://www.wolfssl.com/products/wolfcrypt-post-quantum/ wolfBoot: secure boot and more | Unique features to assist and optimize firmware updates - wolfSSL https://www.wolfssl.com/wolfboot-secure-boot-and-more-unique-features-to-assist-and-optimize-firmware-updates/ Future crypto library features - mbed-tls - lists.trustedfirmware.org https://lists.trustedfirmware.org/archives/list/mbed-tls@lists.trustedfirmware.org/thread/ UI7LWXYYOB7NDUSESBYZ3INHAX5ZNYDM/ STMicroelectronics reveals solutions for post-quantum cryptography, bringing quantum resistance to embedded systems - ST News https://newsroom.st.com/media-center/press-item.html/n4680.html ### Microchip Brings Hardware Quantum Resistance to Embedded Controllers :: Microchip ### Technology Incorporated (MCHP) https://ir.microchip.com/news-events/press-releases/detail/1312/microchip-brings-hardware-quantum-resistance-to- embedded-controllers PQClean/PQClean: Clean, portable, tested implementations of post ... https://github.com/PQClean/PQClean gsma.com https://www.gsma.com/solutions-and-impact/technologies/security/wp-content/uploads/2025/02/Post-Quantum- Cryptography-Executice-Summary-Feb-2025.pdf 13 16 17 18 29 19 20 21 22 23 24 25 28 30 32 33 34 6
